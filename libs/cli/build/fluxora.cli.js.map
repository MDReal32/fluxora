{"version":3,"file":"fluxora.cli.js","sources":["../src/utils/logger.ts","../src/utils/command.ts","../src/commands/index.ts","../src/utils/commands.ts","../src/main.ts"],"sourcesContent":["import { createLogger } from \"@fluxora/utils\";\n\nexport const logger = createLogger({\n  name: \"fluxora/cli\",\n  logLevel: process.env.LOG_LEVEL || \"info\"\n});\n","import type { CamelCase, Promisable } from \"type-fest\";\nimport type { Arguments } from \"yargs\";\n\nimport type { LiteralType } from \"../types/commands/literal-type\";\nimport type { Merge } from \"../types/commands/merge\";\nimport type { OptionType } from \"../types/commands/option-type\";\nimport type { InferType } from \"../types/infer/infer-type\";\nimport { logger } from \"./logger\";\n\ntype CommandOptions<TOptions extends Record<string, LiteralType>> = {\n  [K in keyof TOptions]: OptionType<TOptions[K]>;\n};\n\nexport interface CommandReturnType<TOptions extends Record<string, LiteralType>> {\n  command: string;\n  description: string | null;\n  options: CommandOptions<TOptions>;\n  execute(args: Omit<Arguments, \"_\" | \"$0\">): Promise<void>;\n}\n\nexport class Command<TOptions extends Record<string, LiteralType> = {}> {\n  private options = {} as CommandOptions<TOptions>;\n\n  constructor(\n    private readonly command: string,\n    private readonly description?: string\n  ) {\n    logger.debug(`Created command: ${command} - ${description}`);\n  }\n\n  option<TName extends string, TType extends LiteralType, TAliasName extends string = TName>(\n    name: TName,\n    type: TType | OptionType<TType, TAliasName>\n  ): Command<Merge<TOptions, Record<TName | TAliasName | CamelCase<TName> | CamelCase<TAliasName>, TType>>> {\n    const resolvedValue = (typeof type === \"string\" ? { type } : type) as OptionType<TType>;\n    const defaultValue = resolvedValue.defaultValue || null;\n\n    const self = this as unknown as Command<\n      Merge<TOptions, Record<TName | TAliasName | CamelCase<TName> | CamelCase<TAliasName>, TType>>\n    >;\n    // @ts-ignore\n    self.options[name] = {\n      type: resolvedValue.type,\n      defaultValue,\n      description: resolvedValue.description,\n      alias: resolvedValue.alias\n    } satisfies OptionType<TType>;\n    logger.debug(`Added option: ${name} - Type: ${resolvedValue.type}, Default: ${defaultValue}`);\n    return self;\n  }\n\n  execute(\n    executorFn?: (args: { [K in keyof TOptions]: InferType<TOptions[K]> }) => Promisable<void>\n  ): CommandReturnType<{ [K in keyof TOptions]: TOptions[K] }> {\n    logger.debug(`Setting execute handler for command: ${this.command}`);\n    const self = this;\n    return {\n      command: this.command,\n      description: this.description ?? null,\n      options: this.options,\n      async execute(args) {\n        logger.debug(`Executing command: ${self.command} with args:`, args);\n        await executorFn?.(args as any);\n      }\n    };\n  }\n}\n","import { Command } from \"../utils/command\";\nimport type { CommandsType } from \"../utils/commands\";\nimport { logger } from \"../utils/logger\";\n\nexport const defineCommand = (name: string, description?: string) => {\n  logger.debug(`Defining command: ${name}`);\n  return new Command(name, description);\n};\n\nexport const commands: CommandsType = [import(\"./dev\")];\n","import yargs, { type Arguments } from \"yargs\";\nimport { hideBin } from \"yargs/helpers\";\n\nimport { version } from \"../../package.json\";\nimport { Command, type CommandReturnType } from \"./command\";\nimport { logger } from \"./logger\";\n\nexport type CommandsType = Promise<Record<string, Command<any> | CommandReturnType<any>>>[];\n\nexport class Commands {\n  constructor(private readonly commands: CommandsType) {\n    logger.debug(\"Commands initialized.\");\n  }\n\n  async executeCommands(args = hideBin(process.argv)) {\n    logger.debug(\"Executing commands with args:\", { args });\n    const argv = yargs();\n\n    const commandObjects = await Promise.all(this.commands);\n    const commands = commandObjects\n      .flatMap(obj => Object.values(obj))\n      .map(cmdOrObj => (cmdOrObj instanceof Command ? cmdOrObj.execute() : cmdOrObj));\n\n    for (const cmd of commands) {\n      const { options, description, command: commandStr, execute } = cmd;\n      logger.debug(`Registering command: ${commandStr}`);\n\n      argv.command(\n        commandStr,\n        description || \"\",\n        yargs => {\n          for (const [optionName, optionDetails] of Object.entries(options)) {\n            const { type, defaultValue, alias, description } = optionDetails;\n            logger.debug(\n              `Adding option to command '${commandStr}': ${optionName} (${type})${alias ? ` aliased to ${alias}` : \"\"}`\n            );\n            yargs.option(optionName, {\n              type,\n              alias,\n              description,\n              default: defaultValue ?? undefined\n            });\n          }\n          return yargs.version(false).help().alias(\"help\", \"h\");\n        },\n        async ({ _: _, $0: $0, ...args }: Arguments) => {\n          logger.debug(`Command '${commandStr}' called with args:`, args);\n\n          try {\n            logger.debug(`Executing command '${commandStr}' with args:`, args);\n            await execute(args);\n          } catch (e) {\n            console.error(e);\n            process.exit(1);\n          }\n        }\n      );\n    }\n\n    const commandArgs = args.map(arg => arg.replace(/(?<!-)-\\w/g, m => m.slice(1).toUpperCase()));\n\n    await argv\n      .scriptName(\"fluxora\")\n      .usage(\"$0 <command> [args]\")\n      .help()\n      .alias(\"help\", \"h\")\n      .version(version)\n      .alias(\"version\", \"v\")\n      .strict()\n      .demandCommand(1, \"You need to call one of the given commands or options.\")\n      .parse(commandArgs);\n  }\n}\n","import { commands as commandList } from \"./commands/index\";\nimport { Commands } from \"./utils/commands\";\nimport { logger } from \"./utils/logger\";\n\nexport const cli = async () => {\n  logger.debug(\"Initializing CLI...\");\n  const commands = new Commands(commandList);\n  await commands.executeCommands();\n};\n\nexport type { InferArgs } from \"./types/infer/infer-args\";\n"],"names":["yargs","description","args","commands","commandList"],"mappings":"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"}